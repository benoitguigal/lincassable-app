create type "public"."statut_palox" as enum ('En stock', 'Tri', 'Lavage', 'Point de collecte');

alter type "public"."app_permission" rename to "app_permission__old_version_to_be_dropped";

create type "public"."app_permission" as enum (
    'point_de_collecte.select',
    'point_de_collecte.insert',
    'point_de_collecte.update',
    'point_de_collecte.delete',
    'tournee.select',
    'tournee.insert',
    'tournee.update',
    'tournee.delete',
    'collecte.select',
    'collecte.insert',
    'collecte.update',
    'collecte.delete',
    'transporteur.select',
    'transporteur.insert',
    'transporteur.update',
    'transporteur.delete',
    'transporteur_users.select',
    'transporteur_users.update',
    'transporteur_users.insert',
    'transporteur_users.delete',
    'zone_de_collecte.select',
    'zone_de_collecte.update',
    'zone_de_collecte.insert',
    'zone_de_collecte.delete',
    'prevision.select',
    'mailing.select',
    'mailing.insert',
    'mailing.update',
    'mailing.delete',
    'mail_template.select',
    'mail_statut.select',
    'mail_statut.insert',
    'mail_statut.update',
    'mail_template.update',
    'mail_template.insert',
    'mail_template.delete',
    'inventaire.select',
    'inventaire.update',
    'inventaire.delete',
    'inventaire.insert',
    'palox.select',
    'palox.update',
    'palox.delete',
    'palox.insert'
);

create table "public"."palox" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "numero" text not null,
    "point_de_collecte_id" bigint,
    "statut" statut_palox,
    "model" text null,
    "format_tri" text null,
);

alter table
    "public"."palox" enable row level security;

alter table
    "public"."role_permissions"
alter column
    permission type "public"."app_permission" using permission :: text :: "public"."app_permission";

drop type "public"."app_permission__old_version_to_be_dropped";

CREATE UNIQUE INDEX palox_pkey ON public .palox USING btree (id);

alter table
    "public"."palox"
add
    constraint "palox_pkey" PRIMARY KEY using index "palox_pkey";

alter table
    "public"."palox"
add
    constraint "palox_point_de_collecte_id_fkey" FOREIGN KEY (point_de_collecte_id) REFERENCES point_de_collecte(id) ON
UPDATE
    CASCADE ON
DELETE
SET
    NULL not valid;

alter table
    "public"."palox" validate constraint "palox_point_de_collecte_id_fkey";

grant
delete
    on table "public"."palox" to "anon";

grant
insert
    on table "public"."palox" to "anon";

grant references on table "public"."palox" to "anon";

grant
select
    on table "public"."palox" to "anon";

grant trigger on table "public"."palox" to "anon";

grant truncate on table "public"."palox" to "anon";

grant
update
    on table "public"."palox" to "anon";

grant
delete
    on table "public"."palox" to "authenticated";

grant
insert
    on table "public"."palox" to "authenticated";

grant references on table "public"."palox" to "authenticated";

grant
select
    on table "public"."palox" to "authenticated";

grant trigger on table "public"."palox" to "authenticated";

grant truncate on table "public"."palox" to "authenticated";

grant
update
    on table "public"."palox" to "authenticated";

grant
delete
    on table "public"."palox" to "service_role";

grant
insert
    on table "public"."palox" to "service_role";

grant references on table "public"."palox" to "service_role";

grant
select
    on table "public"."palox" to "service_role";

grant trigger on table "public"."palox" to "service_role";

grant truncate on table "public"."palox" to "service_role";

grant
update
    on table "public"."palox" to "service_role";

create policy "Allow delete for authorized" on "public"."palox" as permissive for
delete
    to authenticated using (
        (
            SELECT
                authorize_user('palox.delete' :: text) AS authorize
        )
    );

create policy "Allow insert for authorized" on "public"."palox" as permissive for
insert
    to authenticated with check (
        (
            SELECT
                authorize_user('palox.insert' :: text) AS authorize
        )
    );

create policy "Allow read for authorized" on "public"."palox" as permissive for
select
    to authenticated using (
        (
            SELECT
                authorize_user('palox.select' :: text) AS authorize
        )
    );

create policy "Allow update for authorized" on "public"."palox" as permissive for
update
    to authenticated using (
        (
            SELECT
                authorize_user('palox.update' :: text) AS authorize
        )
    );